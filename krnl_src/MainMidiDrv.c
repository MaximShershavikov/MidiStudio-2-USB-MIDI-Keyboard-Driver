/**********************************************************************************
    MidiStudio-2 Driver for Windows-10 x64 and Windows-11 x64. Version 1.0.
    Driver for USB MIDI-keyboard MidiStudio-2. The driver is designed for
    Windows-10 x64 and Windows-11 x64

    Copyright (C) 2021  Maxim Shershavikov

    This file is part of MidiStudio-2 Driver.
**********************************************************************************/

#include "MidiStudio2.h"

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    NTSTATUS status;
    PUNICODE_STRING RegPath = &MidiRegistryPath;

    RegPath->MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    RegPath->Length = RegistryPath->Length;
    RegPath->Buffer = ExAllocatePoolWithTag(PagedPool, RegPath->MaximumLength, MIDISTUDIO_02_TAG);

    if (!RegPath->Buffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    memset(RegPath->Buffer, 0, RegPath->MaximumLength);
    memmove(RegPath->Buffer, RegistryPath->Buffer, RegistryPath->Length);

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MidiBulkDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER] = MidiBulkPower;
    DriverObject->MajorFunction[IRP_MJ_PNP] = MidiBulkPnpControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = CreateFileOfPipe;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = CloseFileOfPipe;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = CleanListEntryIrps;
    DriverObject->MajorFunction[IRP_MJ_READ] = ReadMidiData;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = WmiSystemControlDevice;
    DriverObject->DriverUnload = UnloadDrvMidiBulkDevice;

    status = STATUS_SUCCESS;
    DriverObject->DriverExtension->AddDevice = AddMidiBulkDevice;
    return status;
}

NTSTATUS AddMidiBulkDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDeviceObject)
{
    NTSTATUS status;
    PMIDI_DEVICE MidiDevice;
    PDEVICE_OBJECT DeviceObject = NULL;
    POWER_STATE State;

    status = IoCreateDevice(DriverObject, sizeof(MIDI_DEVICE), NULL, FILE_DEVICE_UNKNOWN, FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &DeviceObject);
    if (NT_SUCCESS(status))
    {
        MidiDevice = (PMIDI_DEVICE)DeviceObject->DeviceExtension;
        MidiDevice->DeviceObject = DeviceObject;
        MidiDevice->PhysicalDeviceObject = PhysicalDeviceObject;
        DeviceObject->Flags |= DO_DIRECT_IO;

        KeInitializeSpinLock(&MidiDevice->DeviceStateSpinLock);
        MidiDevice->DeviceState = NotStarted;
        MidiDevice->PrevDevState = NotStarted;
        MidiDevice->OpenHandleCount = 0;

        KeInitializeSpinLock(&MidiDevice->IdleReqSateSpinLock);
        MidiDevice->IdleReqPend = 0;
        MidiDevice->PendingIdleIrp = NULL;
        MidiDevice->QueueState = HoldRequests;

        InitializeListHead(&MidiDevice->ListOfNewRequestsQueue);

        KeInitializeSpinLock(&MidiDevice->IoQueueSpinLock);
        KeInitializeEvent(&MidiDevice->RemoveEvent, SynchronizationEvent, FALSE);
        KeInitializeEvent(&MidiDevice->StopEvent, SynchronizationEvent, TRUE);

        MidiDevice->OutStandingIO = 1;
        KeInitializeSpinLock(&MidiDevice->IoCountSpinLock);

        status = WmiLibContextInit(MidiDevice);
        if (!NT_SUCCESS(status))
        {
            IoDeleteDevice(DeviceObject);
            return status;
        }

        if (PhysicalDeviceObject->Flags & DO_POWER_PAGABLE)
        {
            DeviceObject->Flags |= DO_POWER_PAGABLE;
        }

        MidiDevice->DevicePower = PowerDeviceD0;
        MidiDevice->SystemPower = PowerSystemWorking;
        State.DeviceState = PowerDeviceD0;
        PoSetPowerState(DeviceObject, DevicePowerState, State);
        MidiDevice->NextLowerDeviceObject = IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);
        if (!MidiDevice->NextLowerDeviceObject)
        {
            IoWmiDeRegCtrl(MidiDevice);;
            status = STATUS_NO_SUCH_DEVICE;
            IoDeleteDevice(DeviceObject);
            return status;
        }

        status = IoRegisterDeviceInterface(MidiDevice->PhysicalDeviceObject, &GUID_INTERFACE_MIDI, NULL, &MidiDevice->UnicodeString);
        if (!NT_SUCCESS(status))
        {
            IoWmiDeRegCtrl(MidiDevice);
            IoDetachDevice(MidiDevice->NextLowerDeviceObject);
            IoDeleteDevice(DeviceObject);
            return status;
        }
        MidiDevice->WdmVerWinXpOrBetter = RtlIsNtDdiVersionAvailable(NTDDI_WINXP);
        MidiDevice->SSRegistryEnable = 0;
        MidiDevice->SSEnable = 0;

        if (MidiDevice->WdmVerWinXpOrBetter == TRUE)
        {
            GetValueFromRegistry(L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\BULKUSB\\Parameters", L"ulkUsbEnable", &MidiDevice->SSRegistryEnable);
            if (MidiDevice->SSRegistryEnable)
            {
                KeInitializeDpc(&MidiDevice->Dpc, DeferredRoutineDpc, DeviceObject);
                KeInitializeTimerEx(&MidiDevice->Ktimer, NotificationTimer);
                KeInitializeEvent(&MidiDevice->NoDpcWorkItemPendingEvent, NotificationEvent, TRUE);
                KeInitializeEvent(&MidiDevice->NoIdleRequestPendingEvent, NotificationEvent, TRUE);
            }
        }
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }
    return status;
}

NTSTATUS GetValueFromRegistry(PWCHAR RegPath, PWCHAR ValueName, PULONG Value)
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    ULONG defaultData;
    UNICODE_STRING regPath;
    WCHAR buffer[MAXIMUM_FILENAME_LENGTH];
    NTSTATUS status;

    regPath.Length = 0;
    regPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    regPath.Buffer = buffer;

    memset(regPath.Buffer, 0, regPath.MaximumLength);
    memmove(regPath.Buffer, RegPath, wcslen(RegPath) * sizeof(WCHAR));
    memset(QueryTable, 0, sizeof(QueryTable));
    
    QueryTable[0].Name = ValueName;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultLength = sizeof(ULONG);
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[0].EntryContext = Value;
    QueryTable[0].DefaultData = &defaultData;
    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL, regPath.Buffer, QueryTable, NULL, NULL);
    if (NT_SUCCESS(status))
    {
        return STATUS_SUCCESS;
    }
    *Value = 0;
    return STATUS_UNSUCCESSFUL;
}

VOID UnloadDrvMidiBulkDevice(PDRIVER_OBJECT DriverObject)
{
    PUNICODE_STRING RegPath = &MidiRegistryPath;
    if (RegPath->Buffer)
    {
        ExFreePool(RegPath->Buffer);
        RegPath->Buffer = NULL;
    }
}
